3. Longest Substring Without Repeating Characters
Solved
Medium

Hint
Given a string s, find the length of the longest substring without duplicate characters.

 

Example 1:

Input: s = "abcabcbb"
Output: 3
Explanation: The answer is "abc", with the length of 3.
Example 2:

Input: s = "bbbbb"
Output: 1
Explanation: The answer is "b", with the length of 1.
Example 3:

Input: s = "pwwkew"
Output: 3
Explanation: The answer is "wke", with the length of 3.
Notice that the answer must be a substring, "pwke" is a subsequence and not a substring.
 

Constraints:

0 <= s.length <= 5 * 104
s consists of English letters, digits, symbols and spaces.

```python

    class Solution:
    def lengthOfLongestSubstring(self, s):
        """
        Find the length of the longest substring without repeating characters.
        
        Uses sliding window technique with hash map for O(n) solution.
        
        Args:
            s: Input string
            
        Returns:
            int: Length of longest substring without duplicates
            
        Time Complexity: O(n)
        Space Complexity: O(min(m, n)) where m is charset size
        """
        if not s:
            return 0
        
        # Hash map to store character -> most recent index
        char_index = {}
        max_length = 0
        left = 0  # Left pointer of sliding window
        
        for right in range(len(s)):
            char = s[right]
            
            # If character is seen before and is within current window
            if char in char_index and char_index[char] >= left:
                # Move left pointer to position after the duplicate
                left = char_index[char] + 1
            
            # Update character's most recent position
            char_index[char] = right
            
            # Update maximum length found so far
            max_length = max(max_length, right - left + 1)
        
        return max_length


class SolutionSet:
    def lengthOfLongestSubstring(self, s):
        """
        Alternative approach using a set for the sliding window.
        More intuitive but slightly less efficient.
        
        Time Complexity: O(n) 
        Space Complexity: O(min(m, n))
        """
        if not s:
            return 0
        
        char_set = set()
        max_length = 0
        left = 0
        
        for right in range(len(s)):
            # Shrink window from left until no duplicates
            while s[right] in char_set:
                char_set.remove(s[left])
                left += 1
            
            # Add current character to window
            char_set.add(s[right])
            
            # Update maximum length
            max_length = max(max_length, right - left + 1)
        
        return max_length


class SolutionBruteForce:
    def lengthOfLongestSubstring(self, s):
        """
        Brute force approach - check all substrings.
        Time Complexity: O(n^3)
        Space Complexity: O(min(m, n))
        """
        if not s:
            return 0
        
        max_length = 0
        n = len(s)
        
        for i in range(n):
            for j in range(i, n):
                # Check if substring s[i:j+1] has unique characters
                if self.all_unique(s, i, j):
                    max_length = max(max_length, j - i + 1)
        
        return max_length
    
    def all_unique(self, s, start, end):
        """Check if substring has all unique characters"""
        char_set = set()
        for i in range(start, end + 1):
            if s[i] in char_set:
                return False
            char_set.add(s[i])
        return True


def test_longest_substring():
    """Test all solutions with provided examples"""
    solution = Solution()
    solution_set = SolutionSet()
    solution_brute = SolutionBruteForce()
    
    print("=== Testing Longest Substring Without Repeating Characters ===\n")
    
    test_cases = [
        ("abcabcbb", 3, "abc"),
        ("bbbbb", 1, "b"),
        ("pwwkew", 3, "wke"),
        ("", 0, ""),
        ("dvdf", 3, "vdf"),
        ("anviaj", 5, "nviaj"),
        ("abcdef", 6, "abcdef"),
        ("aab", 2, "ab"),
        ("tmmzuxt", 5, "mzuxt")
    ]
    
    for i, (s, expected_length, example_substring) in enumerate(test_cases, 1):
        print("Test Case {}: s = '{}'".format(i, s))
        print("Expected length: {} (example: '{}')".format(expected_length, example_substring))
        
        # Test optimized hash map solution
        result1 = solution.lengthOfLongestSubstring(s)
        print("Hash Map Solution: {}".format(result1))
        
        # Test set-based solution
        result2 = solution_set.lengthOfLongestSubstring(s)
        print("Set Solution: {}".format(result2))
        
        # Test brute force (only for small inputs)
        if len(s) <= 10:
            result3 = solution_brute.lengthOfLongestSubstring(s)
            print("Brute Force: {}".format(result3))
        
        # Verify all solutions agree
        if result1 == expected_length and result2 == expected_length:
            print("✓ PASSED")
        else:
            print("✗ FAILED")
        
        print("-" * 50)


def find_actual_substring(s):
    """
    Helper function to find and return the actual longest substring.
    Useful for verification and debugging.
    """
    if not s:
        return ""
    
    char_index = {}
    max_length = 0
    max_start = 0
    left = 0
    
    for right in range(len(s)):
        char = s[right]
        
        if char in char_index and char_index[char] >= left:
            left = char_index[char] + 1
        
        char_index[char] = right
        
        if right - left + 1 > max_length:
            max_length = right - left + 1
            max_start = left
    
    return s[max_start:max_start + max_length]


def demo_algorithm():
    """Demonstrate how the sliding window algorithm works step by step"""
    print("\n=== Algorithm Demo: s = 'abcabcbb' ===")
    s = "abcabcbb"
    char_index = {}
    left = 0
    max_length = 0
    
    print("Step-by-step execution:")
    print("Format: [left, right] window='substring' max_len=X")
    
    for right in range(len(s)):
        char = s[right]
        
        if char in char_index and char_index[char] >= left:
            left = char_index[char] + 1
        
        char_index[char] = right
        current_length = right - left + 1
        max_length = max(max_length, current_length)
        
        window = s[left:right+1]
        print("[{}, {}] window='{}' max_len={}".format(left, right, window, max_length))
    
    print("Final answer: {}".format(max_length))


if __name__ == "__main__":
    test_longest_substring()
    demo_algorithm()
    
    print("\n=== Algorithm Comparison ===")
    print("1. Hash Map (Optimized): O(n) time, O(min(m,n)) space - BEST")
    print("2. Set (Sliding Window): O(n) time, O(min(m,n)) space - Good")  
    print("3. Brute Force: O(n³) time, O(min(m,n)) space - Slow")
    print("\nKey insight: Use sliding window to avoid checking all substrings")
