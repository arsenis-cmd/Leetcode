
Solved
Medium

Hint
Given a string s, return the longest palindromic substring in s.

 

Example 1:

Input: s = "babad"
Output: "bab"
Explanation: "aba" is also a valid answer.
Example 2:

Input: s = "cbbd"
Output: "bb"
 

Constraints:

1 <= s.length <= 1000
s consist of only digits and English letters.

```python

    class Solution:
    def longestPalindrome(self, s):
        """
        Find the longest palindromic substring using expand around centers.
        
        Key insight: Every palindrome has a center (either a character or between characters).
        We check all possible centers and expand outward.
        
        Args:
            s: Input string
            
        Returns:
            str: Longest palindromic substring
            
        Time Complexity: O(n²)
        Space Complexity: O(1)
        """
        if not s:
            return ""
        
        start = 0
        max_length = 1
        
        for i in range(len(s)):
            # Check for odd-length palindromes (center at i)
            length1 = self.expandAroundCenter(s, i, i)
            
            # Check for even-length palindromes (center between i and i+1)
            length2 = self.expandAroundCenter(s, i, i + 1)
            
            # Get the longer palindrome from this center
            current_max = max(length1, length2)
            
            # Update global maximum if we found a longer palindrome
            if current_max > max_length:
                max_length = current_max
                # Calculate start position of the palindrome
                start = i - (current_max - 1) // 2
        
        return s[start:start + max_length]
    
    def expandAroundCenter(self, s, left, right):
        """
        Expand around center and return length of palindrome.
        
        Args:
            s: Input string
            left: Left pointer
            right: Right pointer
            
        Returns:
            int: Length of palindrome centered at (left, right)
        """
        while left >= 0 and right < len(s) and s[left] == s[right]:
            left -= 1
            right += 1
        
        # Return length of palindrome
        return right - left - 1


class SolutionDP:
    def longestPalindrome(self, s):
        """
        Dynamic Programming solution.
        dp[i][j] = True if s[i:j+1] is a palindrome
        
        Time Complexity: O(n²)
        Space Complexity: O(n²)
        """
        if not s:
            return ""
        
        n = len(s)
        # dp[i][j] represents whether s[i:j+1] is palindrome
        dp = [[False] * n for _ in range(n)]
        
        start = 0
        max_length = 1
        
        # Every single character is a palindrome
        for i in range(n):
            dp[i][i] = True
        
        # Check for palindromes of length 2
        for i in range(n - 1):
            if s[i] == s[i + 1]:
                dp[i][i + 1] = True
                start = i
                max_length = 2
        
        # Check for palindromes of length 3 and above
        for length in range(3, n + 1):
            for i in range(n - length + 1):
                j = i + length - 1
                
                # Check if s[i:j+1] is palindrome
                if s[i] == s[j] and dp[i + 1][j - 1]:
                    dp[i][j] = True
                    start = i
                    max_length = length
        
        return s[start:start + max_length]


class SolutionBruteForce:
    def longestPalindrome(self, s):
        """
        Brute force: check all substrings.
        Time Complexity: O(n³)
        Space Complexity: O(1)
        """
        if not s:
            return ""
        
        max_palindrome = s[0]
        
        for i in range(len(s)):
            for j in range(i + 1, len(s) + 1):
                substring = s[i:j]
                if self.isPalindrome(substring) and len(substring) > len(max_palindrome):
                    max_palindrome = substring
        
        return max_palindrome
    
    def isPalindrome(self, s):
        """Check if string is palindrome"""
        return s == s[::-1]


class SolutionManacher:
    def longestPalindrome(self, s):
        """
        Manacher's algorithm - optimal O(n) solution.
        More complex but achieves linear time.
        """
        if not s:
            return ""
        
        # Preprocess string: "abc" -> "^#a#b#c#$"
        # ^ and $ are sentinels to avoid boundary checks
        processed = "^#" + "#".join(s) + "#$"
        n = len(processed)
        
        # Array to store radius of palindrome at each position
        radius = [0] * n
        center = right = 0  # Center and right boundary of rightmost palindrome
        
        max_len = 0
        center_index = 0
        
        for i in range(1, n - 1):
            # Mirror of i with respect to center
            mirror = 2 * center - i
            
            # If i is within right boundary, we can use previously computed values
            if i < right:
                radius[i] = min(right - i, radius[mirror])
            
            # Try to expand palindrome centered at i
            while processed[i + radius[i] + 1] == processed[i - radius[i] - 1]:
                radius[i] += 1
            
            # If palindrome centered at i extends past right, update center and right
            if i + radius[i] > right:
                center, right = i, i + radius[i]
            
            # Update maximum length palindrome found
            if radius[i] > max_len:
                max_len = radius[i]
                center_index = i
        
        # Extract the longest palindrome
        start = (center_index - max_len) // 2
        return s[start:start + max_len]


def test_palindrome_solutions():
    """Test all solutions with provided examples and edge cases"""
    solution = Solution()
    solution_dp = SolutionDP()
    solution_brute = SolutionBruteForce()
    solution_manacher = SolutionManacher()
    
    print("=== Testing Longest Palindromic Substring ===\n")
    
    test_cases = [
        ("babad", ["bab", "aba"]),  # Multiple valid answers
        ("cbbd", ["bb"]),
        ("a", ["a"]),
        ("ac", ["a", "c"]),
        ("racecar", ["racecar"]),
        ("noon", ["noon"]),
        ("abcdef", ["a", "b", "c", "d", "e", "f"]),  # No palindrome > 1
        ("aabbaa", ["aabbaa"]),
        ("abacabad", ["abacaba"]),
        ("bananas", ["anana"])
    ]
    
    for i, (s, expected_options) in enumerate(test_cases, 1):
        print("Test Case {}: s = '{}'".format(i, s))
        print("Expected (any of): {}".format(expected_options))
        
        # Test expand around centers (optimal for this problem size)
        result1 = solution.longestPalindrome(s)
        print("Expand Around Centers O(n²): '{}'".format(result1))
        
        # Test dynamic programming
        result2 = solution_dp.longestPalindrome(s)
        print("Dynamic Programming O(n²): '{}'".format(result2))
        
        # Test brute force (only for small inputs)
        if len(s) <= 10:
            result3 = solution_brute.longestPalindrome(s)
            print("Brute Force O(n³): '{}'".format(result3))
        
        # Test Manacher's algorithm
        result4 = solution_manacher.longestPalindrome(s)
        print("Manacher's Algorithm O(n): '{}'".format(result4))
        
        # Verify results
        results = [result1, result2, result4]
        if len(s) <= 10:
            results.append(result3)
        
        all_correct = all(
            result in expected_options or len(result) == len(expected_options[0])
            for result in results
        )
        
        if all_correct:
            print("✓ PASSED")
        else:
            print("✗ FAILED")
        
        print("-" * 60)


def demonstrate_expand_around_centers():
    """Show step-by-step how the expand around centers algorithm works"""
    print("\n=== Algorithm Demo: s = 'babad' ===")
    s = "babad"
    
    print("Checking all possible centers:")
    
    max_length = 1
    best_palindrome = s[0]
    
    for i in range(len(s)):
        # Odd-length palindromes
        left, right = i, i
        while left >= 0 and right < len(s) and s[left] == s[right]:
            current = s[left:right+1]
            print("Center at {}: '{}' (length {})".format(i, current, len(current)))
            if len(current) > max_length:
                max_length = len(current)
                best_palindrome = current
            left -= 1
            right += 1
        
        # Even-length palindromes
        left, right = i, i + 1
        while left >= 0 and right < len(s) and s[left] == s[right]:
            current = s[left:right+1]
            print("Center between {} and {}: '{}' (length {})".format(i, i+1, current, len(current)))
            if len(current) > max_length:
                max_length = len(current)
                best_palindrome = current
            left -= 1
            right += 1
    
    print("Best palindrome found: '{}'".format(best_palindrome))


def analyze_palindrome_properties():
    """Demonstrate palindrome properties and edge cases"""
    print("\n=== Palindrome Properties ===")
    
    examples = [
        ("Single char", "a"),
        ("Two same chars", "bb"), 
        ("Two diff chars", "ab"),
        ("Odd palindrome", "racecar"),
        ("Even palindrome", "abba"),
        ("Nested palindromes", "abacaba"),
        ("No long palindromes", "abcdef")
    ]
    
    solution = Solution()
    
    for desc, s in examples:
        result = solution.longestPalindrome(s)
        print("{}: '{}' -> '{}'".format(desc, s, result))


if __name__ == "__main__":
    test_palindrome_solutions()
    demonstrate_expand_around_centers()
    analyze_palindrome_properties()
    
    print("\n=== Algorithm Comparison ===")
    print("1. Expand Around Centers: O(n²) time, O(1) space - RECOMMENDED")
    print("2. Dynamic Programming: O(n²) time, O(n²) space")  
    print("3. Manacher's Algorithm: O(n) time, O(n) space - OPTIMAL but complex")
    print("4. Brute Force: O(n³) time, O(1) space")
    print("\nFor constraints ≤1000, expand around centers is best balance of efficiency and simplicity!")
