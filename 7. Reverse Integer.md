7. Reverse Integer
Solved
Companies
Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-231, 231 - 1], then return 0.

Assume the environment does not allow you to store 64-bit integers (signed or unsigned).

 

Example 1:

Input: x = 123
Output: 321
Example 2:

Input: x = -123
Output: -321
Example 3:

Input: x = 120
Output: 21
 

Constraints:

-231 <= x <= 231 - 1

```python

        class Solution:
          def reverse(self, x):
              """
              Reverse digits of a 32-bit signed integer.
              Return 0 if reversed integer overflows.
              
              Args:
                  x: 32-bit signed integer
                  
              Returns:
                  int: Reversed integer or 0 if overflow
                  
              Time Complexity: O(log x) - number of digits
              Space Complexity: O(1)
              """
              # 32-bit signed integer bounds
              INT_MAX = 2**31 - 1  # 2147483647
              INT_MIN = -2**31     # -2147483648
              
              # Handle sign separately for cleaner logic
              sign = 1 if x >= 0 else -1
              x = abs(x)
              
              result = 0
              
              while x != 0:
                  digit = x % 10
                  x //= 10
                  
                  # Check for overflow before updating result
                  # We need to check if result * 10 + digit would overflow
                  if result > (INT_MAX - digit) // 10:
                      return 0
                  
                  result = result * 10 + digit
              
              result *= sign
              
              # Final bounds check
              if result > INT_MAX or result < INT_MIN:
                  return 0
                  
              return result
      
      
      class SolutionAlternative:
          def reverse(self, x):
              """
              Alternative approach using string manipulation for clarity.
              Still handles overflow properly.
              """
              # Handle sign
              sign = -1 if x < 0 else 1
              x = abs(x)
              
              # Reverse digits using string
              reversed_str = str(x)[::-1]
              result = int(reversed_str) * sign
              
              # Check bounds
              INT_MAX = 2**31 - 1
              INT_MIN = -2**31
              
              if result > INT_MAX or result < INT_MIN:
                  return 0
              
              return result
      
      
      class SolutionMathematical:
          def reverse(self, x):
              """
              Pure mathematical approach with detailed overflow checking.
              """
              INT_MAX = 2147483647  # 2^31 - 1
              INT_MIN = -2147483648 # -2^31
              
              result = 0
              sign = 1 if x >= 0 else -1
              x = abs(x)
              
              while x > 0:
                  digit = x % 10
                  x //= 10
                  
                  # Check overflow before multiplication and addition
                  # For positive: result > (INT_MAX - digit) / 10
                  # For negative: result > (INT_MIN + digit) / 10 (but with sign)
                  if sign == 1:
                      if result > (INT_MAX - digit) // 10:
                          return 0
                  else:
                      if result > (-(INT_MIN + digit)) // 10:
                          return 0
                  
                  result = result * 10 + digit
              
              return result * sign
      
      
      def test_reverse_integer():
          """Test all solutions with provided examples and edge cases"""
          solution = Solution()
          solution_alt = SolutionAlternative()
          solution_math = SolutionMathematical()
          
          print("=== Testing Reverse Integer ===\n")
          
          test_cases = [
              (123, 321),
              (-123, -321),
              (120, 21),
              (0, 0),
              (1534236469, 0),    # Overflow case
              (-2147483648, 0),   # INT_MIN overflow
              (2147483647, 0),    # Near INT_MAX overflow
              (1463847412, 2147483641),  # Close to limit but valid
              (-1563847412, 0),   # This should overflow: reversed = -2147483651 < INT_MIN
              (7, 7),             # Single digit
              (-7, -7),           # Single negative digit
              (10, 1),            # Trailing zeros
              (100, 1),           # Multiple trailing zeros
              (1000000003, 3000000001)  # This should overflow
          ]
          
          for i, (x, expected) in enumerate(test_cases, 1):
              print("Test Case {}: x = {}".format(i, x))
              print("Expected: {}".format(expected))
              
              # Test main solution
              result1 = solution.reverse(x)
              print("Mathematical Approach: {}".format(result1))
              
              # Test alternative solution
              result2 = solution_alt.reverse(x)
              print("String Approach: {}".format(result2))
              
              # Test mathematical solution
              result3 = solution_math.reverse(x)
              print("Pure Mathematical: {}".format(result3))
              
              # Verify all solutions agree
              if result1 == expected and result2 == expected and result3 == expected:
                  print("✓ PASSED")
              else:
                  print("✗ FAILED")
              
              print("-" * 50)
      
      
      def demonstrate_overflow_detection():
          """Show how overflow detection works"""
          print("\n=== Overflow Detection Demo ===")
          
          INT_MAX = 2**31 - 1  # 2147483647
          INT_MIN = -2**31     # -2147483648
          
          print("32-bit signed integer range:")
          print("INT_MAX = {} = 2^31 - 1".format(INT_MAX))
          print("INT_MIN = {} = -2^31".format(INT_MIN))
          print()
          
          print("Overflow detection logic:")
          print("Before: result * 10 + digit")
          print("Check: result > INT_MAX // 10")
          print("Special case: result == INT_MAX // 10 and digit > 7")
          print()
          
          # Example of overflow
          x = 1534236469
          print("Example: x = {} (will overflow when reversed)".format(x))
          
          result = 0
          digits = []
          temp_x = x
          
          while temp_x > 0:
              digit = temp_x % 10
              digits.append(digit)
              temp_x //= 10
          
          print("Digits to process: {}".format(digits))
          
          for i, digit in enumerate(digits):
              print("Step {}: result = {}, adding digit = {}".format(i+1, result, digit))
              
              # Check overflow
              if result > INT_MAX // 10 or (result == INT_MAX // 10 and digit > 7):
                  print("  OVERFLOW detected! result * 10 + {} would exceed INT_MAX".format(digit))
                  print("  Return 0")
                  break
              
              result = result * 10 + digit
              print("  New result = {}".format(result))
      
      
      def analyze_edge_cases():
          """Analyze important edge cases"""
          solution = Solution()
          
          print("\n=== Edge Cases Analysis ===")
          
          edge_cases = [
              (2147483647, "INT_MAX"),
              (-2147483648, "INT_MIN"), 
              (1463847412, "Close to overflow but valid"),
              (1534236469, "Causes overflow"),
              (0, "Zero"),
              (10, "Trailing zero"),
              (100, "Multiple trailing zeros"),
              (-120, "Negative with trailing zero")
          ]
          
          for x, description in edge_cases:
              result = solution.reverse(x)
              print("{}: {} -> {}".format(description, x, result))
      
      
      def explain_algorithm_steps():
          """Step-by-step explanation of the main algorithm"""
          print("\n=== Algorithm Steps ===")
          print("1. Initialize result = 0")
          print("2. While x != 0:")
          print("   a. Extract last digit")
          print("   b. Check for overflow BEFORE updating result")
          print("   c. Update result = result * 10 + digit")
          print("   d. Remove last digit from x")
          print("3. Return result")
          print()
          
          print("Key insight: Check overflow before it happens!")
          print("- result > INT_MAX // 10: definitely overflow")
          print("- result == INT_MAX // 10 and digit > 7: overflow")
          print("- Similar logic for negative numbers")
          print()
          
          # Demonstrate with example
          x = 123
          print("Example: x = {}".format(x))
          
          result = 0
          step = 1
          
          while x != 0:
              digit = x % 10
              x //= 10
              
              print("Step {}: digit = {}, x = {}".format(step, digit, x))
              print("  Check overflow: {} > {} // 10? No".format(result, 2**31-1))
              
              result = result * 10 + digit
              print("  result = {} * 10 + {} = {}".format(result//10, digit, result))
              
              step += 1
          
          print("Final result: {}".format(result))
      
      
      def debug_specific_case():
          """Debug the specific failing case"""
          solution = Solution()
          
          print("\n=== Debugging x = -1563847412 ===")
          x = -1563847412
          print("Input: {}".format(x))
          
          # Manual calculation
          print("Manual reversal:")
          print("  -1563847412 -> digits: 2,1,4,7,4,8,3,6,5,1")
          print("  Reversed: -2147483651")
          print("  INT_MIN = -2147483648")
          print("  -2147483651 < -2147483648? Yes - OVERFLOW!")
          
          # Step through algorithm
          sign = 1 if x >= 0 else -1
          x = abs(x)
          result = 0
          
          print("\nStep-by-step:")
          print("sign = {}, x = {}".format(sign, x))
          
          step = 1
          while x != 0:
              digit = x % 10
              x //= 10
              
              print("Step {}: digit = {}, x = {}".format(step, digit, x))
              
              # Check overflow
              if result > (2147483647 - digit) // 10:
                  print("  Overflow detected: {} > ({} - {}) // 10".format(result, 2147483647, digit))
                  print("  Would return 0")
                  break
              
              result = result * 10 + digit
              print("  result = {}".format(result))
              step += 1
          
          final_result = result * sign
          print("Before bounds check: {}".format(final_result))
          
          if final_result > 2147483647 or final_result < -2147483648:
              print("Final bounds check failed - return 0")
              final_result = 0
          
          actual_result = solution.reverse(-1563847412)
          print("Solution result: {}".format(actual_result))
          print("Expected: 0")
          print("Correct: {}".format(actual_result == 0))
      
      
      if __name__ == "__main__":
          # Test the specific failing case first
          debug_specific_case()
          
          test_reverse_integer()
          demonstrate_overflow_detection()
          analyze_edge_cases()
          explain_algorithm_steps()
          
          print("\n=== Key Points ===")
          print("1. Check overflow BEFORE it happens")
          print("2. Handle negative numbers carefully")
          print("3. Trailing zeros disappear naturally")
          print("4. Time: O(log x), Space: O(1)")
          print("5. Don't use 64-bit integers for checking!")
