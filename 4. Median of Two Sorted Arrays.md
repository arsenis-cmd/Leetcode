4. Median of Two Sorted Arrays
Solved
Hard
Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.

The overall run time complexity should be O(log (m+n)).

 

Example 1:

Input: nums1 = [1,3], nums2 = [2]
Output: 2.00000
Explanation: merged array = [1,2,3] and median is 2.
Example 2:

Input: nums1 = [1,2], nums2 = [3,4]
Output: 2.50000
Explanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.
 

Constraints:

nums1.length == m
nums2.length == n
0 <= m <= 1000
0 <= n <= 1000
1 <= m + n <= 2000
-106 <= nums1[i], nums2[i] <= 106

```python

  class Solution:
    def findMedianSortedArrays(self, nums1, nums2):
        """
        Find median of two sorted arrays in O(log(min(m,n))) time.
        
        Key insight: Use binary search to partition arrays such that:
        - Left partition has (m+n+1)//2 elements
        - All elements in left <= all elements in right
        
        Args:
            nums1: First sorted array
            nums2: Second sorted array
            
        Returns:
            float: Median of combined arrays
            
        Time Complexity: O(log(min(m, n)))
        Space Complexity: O(1)
        """
        # Ensure nums1 is the smaller array for efficiency
        if len(nums1) > len(nums2):
            nums1, nums2 = nums2, nums1
        
        m, n = len(nums1), len(nums2)
        total = m + n
        half = (total + 1) // 2  # Elements in left partition
        
        left, right = 0, m
        
        while left <= right:
            # Partition positions
            partition1 = (left + right) // 2
            partition2 = half - partition1
            
            # Elements at partition boundaries
            # Use -infinity/+infinity for out-of-bounds
            max_left1 = float('-inf') if partition1 == 0 else nums1[partition1 - 1]
            min_right1 = float('inf') if partition1 == m else nums1[partition1]
            
            max_left2 = float('-inf') if partition2 == 0 else nums2[partition2 - 1]
            min_right2 = float('inf') if partition2 == n else nums2[partition2]
            
            # Check if partition is correct
            if max_left1 <= min_right2 and max_left2 <= min_right1:
                # Found correct partition
                if total % 2 == 1:
                    # Odd total: median is max of left partition
                    return float(max(max_left1, max_left2))
                else:
                    # Even total: median is average of middle two elements
                    return (max(max_left1, max_left2) + min(min_right1, min_right2)) / 2.0
            
            elif max_left1 > min_right2:
                # Too many elements from nums1 in left partition
                right = partition1 - 1
            else:
                # Too few elements from nums1 in left partition
                left = partition1 + 1
        
        # Should never reach here with valid input
        raise ValueError("Input arrays are not sorted")


class SolutionMerge:
    def findMedianSortedArrays(self, nums1, nums2):
        """
        Brute force approach: merge arrays and find median.
        Time: O(m+n), Space: O(m+n)
        Violates the O(log(m+n)) requirement but easier to understand.
        """
        merged = []
        i = j = 0
        
        # Merge the two sorted arrays
        while i < len(nums1) and j < len(nums2):
            if nums1[i] <= nums2[j]:
                merged.append(nums1[i])
                i += 1
            else:
                merged.append(nums2[j])
                j += 1
        
        # Add remaining elements
        merged.extend(nums1[i:])
        merged.extend(nums2[j:])
        
        # Find median
        n = len(merged)
        if n % 2 == 1:
            return float(merged[n // 2])
        else:
            return (merged[n // 2 - 1] + merged[n // 2]) / 2.0


class SolutionTwoPointers:
    def findMedianSortedArrays(self, nums1, nums2):
        """
        Two pointers approach without creating merged array.
        Time: O(m+n), Space: O(1)
        Still violates time requirement but more space efficient.
        """
        total = len(nums1) + len(nums2)
        target1 = (total - 1) // 2  # Index of first median element
        target2 = total // 2        # Index of second median element
        
        i = j = 0
        current_index = 0
        median_values = []
        
        while current_index <= target2:
            if i < len(nums1) and (j >= len(nums2) or nums1[i] <= nums2[j]):
                current_val = nums1[i]
                i += 1
            else:
                current_val = nums2[j]
                j += 1
            
            if current_index == target1 or current_index == target2:
                median_values.append(current_val)
            
            current_index += 1
        
        return sum(median_values) / len(median_values)


def test_median_solutions():
    """Test all solutions with provided examples"""
    solution = Solution()
    solution_merge = SolutionMerge()
    solution_two_ptr = SolutionTwoPointers()
    
    print("=== Testing Median of Two Sorted Arrays ===\n")
    
    test_cases = [
        ([1, 3], [2], 2.0),
        ([1, 2], [3, 4], 2.5),
        ([0, 0], [0, 0], 0.0),
        ([], [1], 1.0),
        ([2], [], 2.0),
        ([1, 3], [2, 4], 2.5),
        ([4, 5, 6], [1, 2, 3], 3.5),
        ([1, 2, 3, 4, 5], [6, 7, 8, 9, 10], 5.5),
        ([1, 3, 8, 9, 15], [7, 11, 18, 19, 21, 25], 9.0)
    ]
    
    for i, (nums1, nums2, expected) in enumerate(test_cases, 1):
        print("Test Case {}: nums1={}, nums2={}".format(i, nums1, nums2))
        print("Expected: {}".format(expected))
        
        # Test binary search solution (optimal)
        result1 = solution.findMedianSortedArrays(nums1, nums2)
        print("Binary Search O(log(min(m,n))): {}".format(result1))
        
        # Test merge solution
        result2 = solution_merge.findMedianSortedArrays(nums1, nums2)
        print("Merge O(m+n): {}".format(result2))
        
        # Test two pointers solution
        result3 = solution_two_ptr.findMedianSortedArrays(nums1, nums2)
        print("Two Pointers O(m+n): {}".format(result3))
        
        # Verify all solutions agree
        if abs(result1 - expected) < 1e-5 and abs(result2 - expected) < 1e-5 and abs(result3 - expected) < 1e-5:
            print("✓ PASSED")
        else:
            print("✗ FAILED")
        
        print("-" * 60)


def explain_binary_search_approach():
    """Detailed explanation of the binary search algorithm"""
    print("\n=== Binary Search Algorithm Explanation ===")
    print("Goal: Partition both arrays such that:")
    print("1. Left partition has exactly (m+n+1)//2 elements")
    print("2. max(left_partition) <= min(right_partition)")
    print()
    
    print("Example: nums1=[1,3], nums2=[2]")
    print("Total elements: 3, so left partition needs (3+1)//2 = 2 elements")
    print()
    
    print("Try partition1=1 (take 1 element from nums1):")
    print("  partition2 = 2-1 = 1 (take 1 element from nums2)")
    print("  Left: [1] from nums1, [2] from nums2 -> max_left = max(1,2) = 2")
    print("  Right: [3] from nums1, [] from nums2 -> min_right = min(3,inf) = 3")
    print("  Check: max_left(2) <= min_right(3) ✓")
    print("  Odd total, so median = max_left = 2")
    print()
    
    print("Key insight: Binary search on smaller array to find correct partition!")


def demonstrate_edge_cases():
    """Show how the algorithm handles edge cases"""
    solution = Solution()
    print("\n=== Edge Cases Demonstration ===")
    
    edge_cases = [
        ([], [1, 2, 3]),
        ([1], [2, 3, 4, 5]),
        ([1, 1, 1], [1, 1, 1]),
        ([-5, -2], [-3, -1])
    ]
    
    for nums1, nums2 in edge_cases:
        result = solution.findMedianSortedArrays(nums1, nums2)
        print("nums1={}, nums2={} -> median={}".format(nums1, nums2, result))


if __name__ == "__main__":
    test_median_solutions()
    explain_binary_search_approach()
    demonstrate_edge_cases()
    
    print("\n=== Algorithm Comparison ===")
    print("1. Binary Search: O(log(min(m,n))) time, O(1) space - OPTIMAL")
    print("2. Merge Arrays: O(m+n) time, O(m+n) space")  
    print("3. Two Pointers: O(m+n) time, O(1) space")
    print("\nOnly binary search meets the O(log(m+n)) requirement!")
