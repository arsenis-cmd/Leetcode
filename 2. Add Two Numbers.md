2. Add Two Numbers
Solved
Medium

You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.

You may assume the two numbers do not contain any leading zero, except the number 0 itself.

 

Example 1:


Input: l1 = [2,4,3], l2 = [5,6,4]
Output: [7,0,8]
Explanation: 342 + 465 = 807.
Example 2:

Input: l1 = [0], l2 = [0]
Output: [0]
Example 3:

Input: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
Output: [8,9,9,9,0,0,0,1]
 

Constraints:

The number of nodes in each linked list is in the range [1, 100].
0 <= Node.val <= 9
It is guaranteed that the list represents a number that does not have leading zeros.

 ```python

  class Solution:
    def addTwoNumbers(self, l1, l2):
        """
        Add two numbers represented as linked lists in reverse order.
        
        Args:
            l1: First number as linked list (digits in reverse order)
            l2: Second number as linked list (digits in reverse order)
            
        Returns:
            Sum as linked list (digits in reverse order)
            
        Time Complexity: O(max(m, n)) where m, n are lengths of l1, l2
        Space Complexity: O(max(m, n)) for the result list
        """
        # Create dummy head to simplify list building
        dummy_head = ListNode(0)
        current = dummy_head
        carry = 0
        
        # Process both lists while either has nodes or there's a carry
        while l1 or l2 or carry:
            # Get values from current nodes (0 if node is None)
            val1 = l1.val if l1 else 0
            val2 = l2.val if l2 else 0
            
            # Calculate sum and new carry
            total = val1 + val2 + carry
            carry = total // 10
            digit = total % 10
            
            # Create new node with the digit
            current.next = ListNode(digit)
            current = current.next
            
            # Move to next nodes if they exist
            l1 = l1.next if l1 else None
            l2 = l2.next if l2 else None
        
        # Return the result (skip dummy head)
        return dummy_head.next


# Note: ListNode class is provided by the testing framework
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next


# Helper functions for testing (only needed if running standalone)
def create_linked_list(digits):
    """Create a linked list from a list of digits"""
    if not digits:
        return None
    
    head = ListNode(digits[0])
    current = head
    
    for digit in digits[1:]:
        current.next = ListNode(digit)
        current = current.next
    
    return head


def linked_list_to_list(head):
    """Convert linked list back to Python list for easy comparison"""
    result = []
    current = head
    while current:
        result.append(current.val)
        current = current.next
    return result


def linked_list_to_number(head):
    """Convert linked list to actual number (for verification)"""
    digits = linked_list_to_list(head)
    # Reverse since digits are stored in reverse order
    digits.reverse()
    number = 0
    for digit in digits:
        number = number * 10 + digit
    return number


def test_add_two_numbers():
    """Test the solution with provided examples"""
    solution = Solution()
    
    print("=== Testing Add Two Numbers ===\n")
    
    test_cases = [
        ([2, 4, 3], [5, 6, 4], [7, 0, 8]),  # 342 + 465 = 807
        ([0], [0], [0]),                     # 0 + 0 = 0
        ([9, 9, 9, 9, 9, 9, 9], [9, 9, 9, 9], [8, 9, 9, 9, 0, 0, 0, 1]),  # 9999999 + 9999 = 10009998
        ([5], [5], [0, 1]),                  # 5 + 5 = 10
        ([1, 8], [0], [1, 8]),               # 81 + 0 = 81
        ([9, 9], [1], [0, 0, 1])             # 99 + 1 = 100
    ]
    
    for i, (l1_digits, l2_digits, expected) in enumerate(test_cases, 1):
        print("Test Case {}: {} + {}".format(i, l1_digits, l2_digits))
        
        # Create linked lists
        l1 = create_linked_list(l1_digits)
        l2 = create_linked_list(l2_digits)
        
        # Add the numbers
        result = solution.addTwoNumbers(l1, l2)
        result_digits = linked_list_to_list(result)
        
        print("Expected: {}".format(expected))
        print("Got:      {}".format(result_digits))
        
        # Verify correctness by converting to actual numbers
        num1 = linked_list_to_number(create_linked_list(l1_digits))
        num2 = linked_list_to_number(create_linked_list(l2_digits))
        expected_sum = num1 + num2
        actual_sum = linked_list_to_number(result)
        
        print("Verification: {} + {} = {} (expected: {})".format(
            num1, num2, actual_sum, expected_sum))
        
        if result_digits == expected and actual_sum == expected_sum:
            print("✓ PASSED")
        else:
            print("✗ FAILED")
        
        print("-" * 50)


# Alternative implementation using recursion
class SolutionRecursive:
    def addTwoNumbers(self, l1, l2, carry=0):
        """
        Recursive approach to add two numbers.
        More elegant but uses O(max(m,n)) stack space.
        """
        # Base case: no more nodes and no carry
        if not l1 and not l2 and carry == 0:
            return None
        
        # Get values (0 if node is None)
        val1 = l1.val if l1 else 0
        val2 = l2.val if l2 else 0
        
        # Calculate sum
        total = val1 + val2 + carry
        digit = total % 10
        new_carry = total // 10
        
        # Create current node
        result = ListNode(digit)
        
        # Get next nodes
        next1 = l1.next if l1 else None
        next2 = l2.next if l2 else None
        
        # Recursively process remaining nodes
        result.next = self.addTwoNumbers(next1, next2, new_carry)
        
        return result


if __name__ == "__main__":
    test_add_two_numbers()
    
    print("\n=== Algorithm Analysis ===")
    print("Time Complexity: O(max(m, n)) - visit each node once")
    print("Space Complexity: O(max(m, n)) - for the result linked list")
    print("Key Insight: Process digits left-to-right since they're in reverse order")
    print("Handle carry propagation carefully, especially for different length lists")
