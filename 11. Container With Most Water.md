11. Container With Most Water
Solved
Medium
Hint
You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).

Find two lines that together with the x-axis form a container, such that the container contains the most water.

Return the maximum amount of water a container can store.

Notice that you may not slant the container.

 

Example 1:


Input: height = [1,8,6,2,5,4,8,3,7]
Output: 49
Explanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.
Example 2:

Input: height = [1,1]
Output: 1
 

Constraints:

n == height.length
2 <= n <= 105
0 <= height[i] <= 104

```python

    class Solution:
    def maxArea(self, height):
        """
        Find maximum water area using two pointers approach.
        
        Key insight: Start with widest container and move pointer
        from the shorter line inward to potentially find larger area.
        
        Args:
            height: List of line heights
            
        Returns:
            int: Maximum water area
            
        Time Complexity: O(n)
        Space Complexity: O(1)
        """
        left = 0
        right = len(height) - 1
        max_area = 0
        
        while left < right:
            # Calculate current area
            width = right - left
            current_height = min(height[left], height[right])
            current_area = width * current_height
            
            # Update maximum area
            max_area = max(max_area, current_area)
            
            # Move pointer from shorter line
            # This is the key optimization: moving the taller line
            # can never give us a better result with current shorter line
            if height[left] < height[right]:
                left += 1
            else:
                right -= 1
        
        return max_area


class SolutionBruteForce:
    def maxArea(self, height):
        """
        Brute force approach: check all possible pairs.
        Time: O(n²), Space: O(1)
        
        Included for comparison and understanding.
        """
        max_area = 0
        n = len(height)
        
        for i in range(n):
            for j in range(i + 1, n):
                width = j - i
                current_height = min(height[i], height[j])
                area = width * current_height
                max_area = max(max_area, area)
        
        return max_area


class SolutionDetailed:
    def maxArea(self, height):
        """
        Detailed version with step-by-step reasoning for learning.
        """
        left = 0
        right = len(height) - 1
        max_area = 0
        
        while left < right:
            # Current container dimensions
            width = right - left
            left_height = height[left]
            right_height = height[right]
            
            # Water level is limited by shorter line
            water_level = min(left_height, right_height)
            current_area = width * water_level
            
            # Track maximum area seen so far
            max_area = max(max_area, current_area)
            
            # Key decision: which pointer to move?
            # Move the pointer at the shorter line because:
            # 1. Moving the taller line decreases width but height stays same
            # 2. Moving the shorter line might find a taller line
            if left_height < right_height:
                left += 1
            elif right_height < left_height:
                right -= 1
            else:
                # Equal heights: move either (we choose left)
                left += 1
        
        return max_area


def test_container_solutions():
    """Test all solutions with provided examples and edge cases"""
    solution = Solution()
    solution_brute = SolutionBruteForce()
    solution_detailed = SolutionDetailed()
    
    print("=== Testing Container With Most Water ===\n")
    
    test_cases = [
        ([1, 8, 6, 2, 5, 4, 8, 3, 7], 49),
        ([1, 1], 1),
        ([4, 3, 2, 1, 4], 16),
        ([1, 2, 1], 2),
        ([1, 2, 4, 3], 4),
        ([2, 1], 1),
        ([1, 3, 2, 5, 25, 24, 5], 24),
        ([1, 8, 100, 2, 6, 4, 8, 3, 7], 200),
        ([5, 5, 5, 5], 15),
        ([1, 0, 0, 0, 0, 0, 0, 2, 1], 8)
    ]
    
    for i, (heights, expected) in enumerate(test_cases, 1):
        print("Test Case {}: height = {}".format(i, heights))
        print("Expected: {}".format(expected))
        
        # Test optimized two-pointer solution
        result1 = solution.maxArea(heights)
        print("Two Pointers O(n): {}".format(result1))
        
        # Test brute force (only for small inputs)
        if len(heights) <= 10:
            result2 = solution_brute.maxArea(heights)
            print("Brute Force O(n²): {}".format(result2))
        
        # Test detailed solution
        result3 = solution_detailed.maxArea(heights)
        print("Detailed Solution: {}".format(result3))
        
        # Verify solutions agree
        all_correct = result1 == expected and result3 == expected
        if len(heights) <= 10:
            all_correct = all_correct and result2 == expected
        
        if all_correct:
            print("✓ PASSED")
        else:
            print("✗ FAILED")
        
        print("-" * 50)


def demonstrate_two_pointer_algorithm():
    """Show step-by-step how two-pointer algorithm works"""
    print("\n=== Two-Pointer Algorithm Demo ===")
    
    height = [1, 8, 6, 2, 5, 4, 8, 3, 7]
    print("Height array: {}".format(height))
    print("Indices:      {}".format(list(range(len(height)))))
    print()
    
    left = 0
    right = len(height) - 1
    max_area = 0
    step = 1
    
    print("Step-by-step execution:")
    
    while left < right:
        width = right - left
        current_height = min(height[left], height[right])
        area = width * current_height
        max_area = max(max_area, area)
        
        print("Step {}: left={}, right={}, heights=({},{}), width={}, area={}".format(
            step, left, right, height[left], height[right], width, area))
        print("  Max area so far: {}".format(max_area))
        
        # Decide which pointer to move
        if height[left] < height[right]:
            print("  Move left pointer (shorter line)")
            left += 1
        else:
            print("  Move right pointer (shorter or equal line)")
            right -= 1
        
        step += 1
        print()
    
    print("Final maximum area: {}".format(max_area))


def explain_why_two_pointers_work():
    """Explain the mathematical reasoning behind two-pointer approach"""
    print("\n=== Why Two Pointers Work ===")
    
    print("Key insight: We can eliminate suboptimal solutions systematically")
    print()
    
    print("Consider container between positions i and j where height[i] < height[j]:")
    print("- Current area = (j - i) * height[i]")
    print("- Any container using i with k where i < k < j will have:")
    print("  - Smaller width: (k - i) < (j - i)")
    print("  - Same or smaller height: min(height[i], height[k]) ≤ height[i]")
    print("  - Therefore: area ≤ current area")
    print()
    
    print("This means we can safely move the left pointer without missing optimal solution!")
    print()
    
    print("Visual example:")
    print("Height: [1, 8, 6, 2, 5, 4, 8, 3, 7]")
    print("        ^                       ^")
    print("      i=0                     j=8")
    print("Area = 8 * min(1, 7) = 8 * 1 = 8")
    print()
    print("Any container using position 0 with positions 1-7:")
    print("- (0,1): width=1, height=min(1,8)=1, area=1 < 8")
    print("- (0,2): width=2, height=min(1,6)=1, area=2 < 8") 
    print("- ...")
    print("- (0,7): width=7, height=min(1,3)=1, area=7 < 8")
    print()
    print("So we can safely move from position 0 to position 1!")


def visualize_container():
    """Visualize the container concept"""
    print("\n=== Container Visualization ===")
    
    height = [1, 8, 6, 2, 5, 4, 8, 3, 7]
    print("Array: {}".format(height))
    print()
    
    # Find the optimal solution to visualize
    left = 0
    right = len(height) - 1
    max_area = 0
    best_left, best_right = 0, 0
    
    while left < right:
        area = (right - left) * min(height[left], height[right])
        if area > max_area:
            max_area = area
            best_left, best_right = left, right
        
        if height[left] < height[right]:
            left += 1
        else:
            right -= 1
    
    print("Optimal container: positions {} and {}".format(best_left, best_right))
    print("Heights: {} and {}".format(height[best_left], height[best_right]))
    print("Width: {}".format(best_right - best_left))
    print("Water level: {}".format(min(height[best_left], height[best_right])))
    print("Area: {}".format(max_area))
    print()
    
    # Simple ASCII visualization
    max_height = max(height)
    print("Container visualization:")
    for level in range(max_height, 0, -1):
        line = ""
        for i, h in enumerate(height):
            if i == best_left or i == best_right:
                line += "|" if h >= level else " "
            elif best_left < i < best_right and level <= min(height[best_left], height[best_right]):
                line += "~"  # Water
            elif h >= level:
                line += "|"
            else:
                line += " "
        print(line)
    
    # Print position numbers
    print("".join(str(i) for i in range(len(height))))


def analyze_complexity():
    """Analyze time and space complexity"""
    print("\n=== Complexity Analysis ===")
    
    print("Two-Pointer Approach:")
    print("- Time Complexity: O(n)")
    print("  Each element is visited at most once")
    print("  We move inward from both ends until pointers meet")
    print()
    print("- Space Complexity: O(1)")
    print("  Only using a few variables regardless of input size")
    print()
    
    print("Brute Force Approach:")
    print("- Time Complexity: O(n²)")
    print("  Check all possible pairs: C(n,2) = n(n-1)/2")
    print("- Space Complexity: O(1)")
    print("  Only using a few variables")
    print()
    
    print("Why Two-Pointer is Optimal:")
    print("- Eliminates impossible solutions systematically")
    print("- Never misses the optimal solution")
    print("- Linear time with constant space")
    print("- Much faster for large inputs (n ≤ 10⁵)")


if __name__ == "__main__":
    test_container_solutions()
    demonstrate_two_pointer_algorithm()
    explain_why_two_pointers_work()
    visualize_container()
    analyze_complexity()
    
    print("\n=== Key Takeaways ===")
    print("1. Two-pointer technique eliminates suboptimal solutions")
    print("2. Always move pointer from shorter line")
    print("3. Width × min(height) gives area")
    print("4. O(n) time beats O(n²) brute force significantly")
    print("5. Classic greedy approach that actually works!")
