10. Regular Expression Matching
Solved
Hard
Given an input string s and a pattern p, implement regular expression matching with support for '.' and '*' where:

'.' Matches any single character.​​​​
'*' Matches zero or more of the preceding element.
The matching should cover the entire input string (not partial).

 

Example 1:

Input: s = "aa", p = "a"
Output: false
Explanation: "a" does not match the entire string "aa".
Example 2:

Input: s = "aa", p = "a*"
Output: true
Explanation: '*' means zero or more of the preceding element, 'a'. Therefore, by repeating 'a' once, it becomes "aa".
Example 3:

Input: s = "ab", p = ".*"
Output: true
Explanation: ".*" means "zero or more (*) of any character (.)".
 

Constraints:

1 <= s.length <= 20
1 <= p.length <= 20
s contains only lowercase English letters.
p contains only lowercase English letters, '.', and '*'.
It is guaranteed for each appearance of the character '*', there will be a previous valid character to match.

  ```python

    class Solution:
    def isMatch(self, s, p):
        """
        Regular expression matching with '.' and '*' support.
        
        Dynamic Programming approach:
        dp[i][j] = True if s[0:i] matches p[0:j]
        
        Key cases:
        1. If p[j-1] == '*': 
           - Match zero occurrences: dp[i][j-2]
           - Match one or more: dp[i-1][j] (if current chars match)
        2. If current chars match: dp[i-1][j-1]
        
        Args:
            s: Input string
            p: Pattern with '.' and '*'
            
        Returns:
            bool: True if pattern matches entire string
            
        Time Complexity: O(m*n) where m=len(s), n=len(p)
        Space Complexity: O(m*n)
        """
        m, n = len(s), len(p)
        
        # dp[i][j] represents if s[0:i] matches p[0:j]
        dp = [[False] * (n + 1) for _ in range(m + 1)]
        
        # Base case: empty string matches empty pattern
        dp[0][0] = True
        
        # Handle patterns like "a*", "a*b*", etc. that can match empty string
        for j in range(2, n + 1):
            if p[j - 1] == '*':
                dp[0][j] = dp[0][j - 2]
        
        # Fill the DP table
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                if p[j - 1] == '*':
                    # Star can match zero or more of preceding character
                    # Case 1: Match zero occurrences (ignore x*)
                    dp[i][j] = dp[i][j - 2]
                    
                    # Case 2: Match one or more occurrences
                    # Check if current character matches the character before '*'
                    if self.matches(s[i - 1], p[j - 2]):
                        dp[i][j] = dp[i][j] or dp[i - 1][j]
                else:
                    # Regular character or '.' matching
                    if self.matches(s[i - 1], p[j - 1]):
                        dp[i][j] = dp[i - 1][j - 1]
        
        return dp[m][n]
    
    def matches(self, s_char, p_char):
        """Check if pattern character matches string character"""
        return p_char == '.' or s_char == p_char


class SolutionRecursive:
    def isMatch(self, s, p):
        """
        Recursive solution with memoization.
        More intuitive but potentially less efficient due to recursion overhead.
        """
        memo = {}
        
        def dp(i, j):
            # i: current position in string s
            # j: current position in pattern p
            
            if (i, j) in memo:
                return memo[(i, j)]
            
            # Base case: reached end of pattern
            if j == len(p):
                return i == len(s)
            
            # Check if current characters match
            first_match = i < len(s) and (p[j] == s[i] or p[j] == '.')
            
            # Handle '*' case
            if j + 1 < len(p) and p[j + 1] == '*':
                # Two options:
                # 1. Skip the "x*" pattern (match zero occurrences)
                # 2. Use the "x*" pattern if current chars match
                result = (dp(i, j + 2) or 
                         (first_match and dp(i + 1, j)))
            else:
                # Regular matching: both current chars must match and rest must match
                result = first_match and dp(i + 1, j + 1)
            
            memo[(i, j)] = result
            return result
        
        return dp(0, 0)


class SolutionBottomUp:
    def isMatch(self, s, p):
        """
        Bottom-up DP with detailed comments for understanding.
        """
        m, n = len(s), len(p)
        
        # Create DP table with extra row/column for empty string/pattern
        dp = [[False] * (n + 1) for _ in range(m + 1)]
        
        # Empty string matches empty pattern
        dp[0][0] = True
        
        # Fill first row: empty string with various patterns
        for j in range(1, n + 1):
            if j >= 2 and p[j - 1] == '*':
                # Pattern like "a*" can match empty string
                dp[0][j] = dp[0][j - 2]
        
        # Fill the rest of the table
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                current_char = s[i - 1]
                pattern_char = p[j - 1]
                
                if pattern_char == '*':
                    # The '*' applies to the character before it
                    prev_pattern_char = p[j - 2]
                    
                    # Option 1: Match zero occurrences of prev_pattern_char
                    dp[i][j] = dp[i][j - 2]
                    
                    # Option 2: Match one or more occurrences
                    if prev_pattern_char == '.' or prev_pattern_char == current_char:
                        dp[i][j] = dp[i][j] or dp[i - 1][j]
                
                elif pattern_char == '.' or pattern_char == current_char:
                    # Characters match, check if previous state was valid
                    dp[i][j] = dp[i - 1][j - 1]
        
        return dp[m][n]


def test_regex_matching():
    """Test all solutions with provided examples and complex cases"""
    solution = Solution()
    solution_recursive = SolutionRecursive()
    solution_bottom_up = SolutionBottomUp()
    
    print("=== Testing Regular Expression Matching ===\n")
    
    test_cases = [
        ("aa", "a", False),
        ("aa", "a*", True),
        ("ab", ".*", True),
        ("aab", "c*a*b", True),
        ("mississippi", "mis*is*p*.", False),
        ("", "", True),
        ("", "a*", True),
        ("", "a*b*", True),
        ("a", "", False),
        ("a", "a", True),
        ("a", "ab*", True),
        ("ab", "a*b", True),
        ("aaa", "a*a", True),
        ("aaa", "ab*a*c*a", True),
        ("abcd", "d*", False),
        ("a", ".*", True),
        ("", ".*", True),
        ("abc", "a.c", True),
        ("abc", "a.*c", True),
        ("ac", "ab*c", True),
        ("abcdef", "a.*f", True),
        ("a", "a*a", True),
        ("aa", "a*a", True),
        ("aab", "a*b", True),
        ("bbbba", ".*a*a", True)
    ]
    
    for i, (s, p, expected) in enumerate(test_cases, 1):
        print("Test Case {}: s='{}', p='{}'".format(i, s, p))
        print("Expected: {}".format(expected))
        
        # Test DP solution
        result1 = solution.isMatch(s, p)
        print("DP Solution: {}".format(result1))
        
        # Test recursive solution
        result2 = solution_recursive.isMatch(s, p)
        print("Recursive Solution: {}".format(result2))
        
        # Test bottom-up solution
        result3 = solution_bottom_up.isMatch(s, p)
        print("Bottom-up Solution: {}".format(result3))
        
        # Verify all solutions agree
        if result1 == expected and result2 == expected and result3 == expected:
            print("✓ PASSED")
        else:
            print("✗ FAILED")
        
        print("-" * 50)


def demonstrate_dp_table():
    """Show how the DP table is filled for a specific example"""
    print("\n=== DP Table Demonstration ===")
    
    s = "aab"
    p = "c*a*b"
    
    print("String: '{}', Pattern: '{}'".format(s, p))
    print("Expected: True (c* matches 0 c's, a* matches 2 a's, b matches b)")
    print()
    
    m, n = len(s), len(p)
    dp = [[False] * (n + 1) for _ in range(m + 1)]
    
    # Base case
    dp[0][0] = True
    
    # Handle empty string with patterns
    for j in range(2, n + 1):
        if p[j - 1] == '*':
            dp[0][j] = dp[0][j - 2]
    
    print("Initial state (after handling empty string):")
    print_dp_table(dp, s, p)
    print()
    
    # Fill table step by step
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if p[j - 1] == '*':
                dp[i][j] = dp[i][j - 2]  # Zero occurrences
                if p[j - 2] == '.' or p[j - 2] == s[i - 1]:
                    dp[i][j] = dp[i][j] or dp[i - 1][j]  # One or more
            else:
                if p[j - 1] == '.' or p[j - 1] == s[i - 1]:
                    dp[i][j] = dp[i - 1][j - 1]
            
            print("After processing s[{}]='{}' with p[{}]='{}'".format(
                i-1, s[i-1], j-1, p[j-1]))
            print_dp_table(dp, s, p)
            print()
    
    print("Final result: {}".format(dp[m][n]))


def print_dp_table(dp, s, p):
    """Helper function to print DP table in readable format"""
    m, n = len(s), len(p)
    
    # Print header
    print("    ", end="")
    print("ε".rjust(3), end="")
    for char in p:
        print(char.rjust(3), end="")
    print()
    
    # Print rows
    for i in range(m + 1):
        if i == 0:
            print("ε".rjust(3), end=" ")
        else:
            print(s[i-1].rjust(3), end=" ")
        
        for j in range(n + 1):
            print("T" if dp[i][j] else "F", end="  ")
        print()


def explain_star_operator():
    """Explain how the '*' operator works in detail"""
    print("\n=== Understanding the '*' Operator ===")
    
    print("The '*' operator matches ZERO or MORE of the preceding element:")
    print()
    
    examples = [
        ("a*", ["", "a", "aa", "aaa"]),
        ("ab*", ["a", "ab", "abb", "abbb"]),
        (".*", ["", "a", "abc", "anything"]),
        ("a*b", ["b", "ab", "aab", "aaab"])
    ]
    
    for pattern, matches in examples:
        print("Pattern '{}' can match:".format(pattern))
        for match in matches:
            print("  '{}'".format(match if match else "(empty)"))
        print()
    
    print("Key insight: 'x*' gives us two choices:")
    print("1. Match zero x's (ignore the 'x*' entirely)")
    print("2. Match one x and keep the 'x*' for potential future matches")


def analyze_complexity():
    """Analyze time and space complexity"""
    print("\n=== Complexity Analysis ===")
    
    print("Dynamic Programming Approach:")
    print("- Time Complexity: O(m × n)")
    print("  where m = length of string, n = length of pattern")
    print("  We fill an (m+1) × (n+1) table, each cell takes O(1)")
    print()
    print("- Space Complexity: O(m × n)")
    print("  For the DP table")
    print()
    print("Recursive Approach with Memoization:")
    print("- Time Complexity: O(m × n)")
    print("  Each state (i,j) computed at most once")
    print("- Space Complexity: O(m × n)")
    print("  For memoization table + recursion stack")
    print()
    print("Space Optimization:")
    print("- Can reduce space to O(n) by using only two rows")
    print("- Current row depends only on previous row")


def trace_example():
    """Trace through a complex example step by step"""
    print("\n=== Tracing Example: s='aab', p='c*a*b' ===")
    
    print("Step-by-step reasoning:")
    print("1. 'c*' can match 0 c's (skip it)")
    print("2. 'a*' should match 'aa' (2 a's)")  
    print("3. 'b' should match 'b'")
    print()
    
    print("DP states that matter:")
    print("dp[0][0] = True (empty matches empty)")
    print("dp[0][2] = True (empty matches 'c*')")
    print("dp[0][4] = True (empty matches 'c*a*')")
    print("dp[1][4] = True ('a' matches 'c*a*')")
    print("dp[2][4] = True ('aa' matches 'c*a*')")
    print("dp[3][5] = True ('aab' matches 'c*a*b')")


if __name__ == "__main__":
    test_regex_matching()
    demonstrate_dp_table()
    explain_star_operator()
    analyze_complexity()
    trace_example()
    
    print("\n=== Key Insights ===")
    print("1. '*' operator provides two choices: match 0 or match 1+ occurrences")
    print("2. DP state: dp[i][j] = does s[0:i] match p[0:j]")
    print("3. Base cases: empty string and patterns with '*' that can match empty")
    print("4. Critical: '*' applies to the character BEFORE it, not after")
    print("5. '.' matches any single character, '.*' matches any string")
