9. Palindrome Number
Solved
Easy
Hint
Given an integer x, return true if x is a palindrome, and false otherwise.

 

Example 1:

Input: x = 121
Output: true
Explanation: 121 reads as 121 from left to right and from right to left.
Example 2:

Input: x = -121
Output: false
Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.
Example 3:

Input: x = 10
Output: false
Explanation: Reads 01 from right to left. Therefore it is not a palindrome.
 

Constraints:

-231 <= x <= 231 - 1
 

Follow up: Could you solve it without converting the integer to a string?

```python
    class Solution:
    def isPalindrome(self, x):
        """
        Check if integer is palindrome without converting to string.
        
        Key insight: Reverse only half the number to avoid overflow.
        Compare first half with reversed second half.
        
        Args:
            x: Integer to check
            
        Returns:
            bool: True if x is palindrome, False otherwise
            
        Time Complexity: O(log x) - half the digits
        Space Complexity: O(1)
        """
        # Negative numbers are not palindromes
        # Numbers ending in 0 (except 0 itself) are not palindromes
        if x < 0 or (x % 10 == 0 and x != 0):
            return False
        
        # Special case: single digit numbers are palindromes
        if x < 10:
            return True
        
        reversed_half = 0
        
        # Reverse only half the digits
        # Stop when original number <= reversed half
        while x > reversed_half:
            reversed_half = reversed_half * 10 + x % 10
            x //= 10
        
        # For even length: x == reversed_half
        # For odd length: x == reversed_half // 10 (remove middle digit)
        return x == reversed_half or x == reversed_half // 10


class SolutionFullReverse:
    def isPalindrome(self, x):
        """
        Alternative: Reverse the entire number and compare.
        Simpler logic but need to handle potential overflow.
        """
        if x < 0:
            return False
        
        original = x
        reversed_num = 0
        
        while x > 0:
            reversed_num = reversed_num * 10 + x % 10
            x //= 10
        
        return original == reversed_num


class SolutionString:
    def isPalindrome(self, x):
        """
        String conversion approach (simpler but violates follow-up).
        """
        if x < 0:
            return False
        
        s = str(x)
        return s == s[::-1]


class SolutionDigitArray:
    def isPalindrome(self, x):
        """
        Extract digits into array and use two pointers.
        Educational approach showing digit manipulation.
        """
        if x < 0:
            return False
        
        # Extract all digits
        digits = []
        if x == 0:
            digits = [0]
        else:
            temp = x
            while temp > 0:
                digits.append(temp % 10)
                temp //= 10
        
        # Two pointers approach
        left, right = 0, len(digits) - 1
        
        while left < right:
            if digits[left] != digits[right]:
                return False
            left += 1
            right -= 1
        
        return True


def test_palindrome_solutions():
    """Test all solutions with provided examples and edge cases"""
    solution = Solution()
    solution_full = SolutionFullReverse()
    solution_str = SolutionString()
    solution_array = SolutionDigitArray()
    
    print("=== Testing Palindrome Number ===\n")
    
    test_cases = [
        (121, True),
        (-121, False),
        (10, False),
        (0, True),
        (1, True),
        (11, True),
        (12, False),
        (1221, True),
        (1231, False),
        (12321, True),
        (123454321, True),
        (1234567899876543210, False),  # Very large number
        (9, True),
        (99, True),
        (101, True),
        (1001, True),
        (10001, True),
        (12345, False),
        (1234321, True),
        (-1, False),
        (-11, False),
        (2147447412, True)  # Large palindrome
    ]
    
    for i, (x, expected) in enumerate(test_cases, 1):
        print("Test Case {}: x = {}".format(i, x))
        print("Expected: {}".format(expected))
        
        # Test optimal half-reverse solution
        result1 = solution.isPalindrome(x)
        print("Half Reverse (Optimal): {}".format(result1))
        
        # Test full reverse solution
        result2 = solution_full.isPalindrome(x)
        print("Full Reverse: {}".format(result2))
        
        # Test string solution
        result3 = solution_str.isPalindrome(x)
        print("String Conversion: {}".format(result3))
        
        # Test digit array solution
        result4 = solution_array.isPalindrome(x)
        print("Digit Array: {}".format(result4))
        
        # Verify all solutions agree
        if (result1 == expected and result2 == expected and 
            result3 == expected and result4 == expected):
            print("✓ PASSED")
        else:
            print("✗ FAILED")
        
        print("-" * 50)


def demonstrate_half_reverse_algorithm():
    """Show step-by-step how the half-reverse algorithm works"""
    print("\n=== Half-Reverse Algorithm Demo ===")
    
    examples = [12321, 1221, 12345]
    
    for x in examples:
        print("Number: {}".format(x))
        original_x = x
        reversed_half = 0
        step = 1
        
        print("Step-by-step execution:")
        
        while x > reversed_half:
            digit = x % 10
            reversed_half = reversed_half * 10 + digit
            x //= 10
            
            print("Step {}: digit={}, x={}, reversed_half={}".format(
                step, digit, x, reversed_half))
            step += 1
        
        # Check final condition
        even_length_palindrome = (x == reversed_half)
        odd_length_palindrome = (x == reversed_half // 10)
        
        print("Final check:")
        print("  Even length: x({}) == reversed_half({}) ? {}".format(
            x, reversed_half, even_length_palindrome))
        print("  Odd length: x({}) == reversed_half//10({}) ? {}".format(
            x, reversed_half // 10, odd_length_palindrome))
        
        result = even_length_palindrome or odd_length_palindrome
        print("Result: {} is {}palindrome".format(original_x, "" if result else "NOT "))
        print()


def explain_edge_cases():
    """Explain important edge cases and why they work"""
    print("\n=== Edge Cases Explanation ===")
    
    edge_cases = [
        (-121, "Negative numbers", "Cannot be palindromes (minus sign position)"),
        (10, "Trailing zeros", "Would become leading zeros when reversed"),
        (0, "Zero", "Special case - considered palindrome"),
        (5, "Single digit", "All single digits are palindromes"),
        (100, "Multiple trailing zeros", "Cannot be palindromes"),
        (1001, "Internal zeros", "Valid palindrome with zeros in middle")
    ]
    
    solution = Solution()
    
    for x, case_type, explanation in edge_cases:
        result = solution.isPalindrome(x)
        print("{}: {} -> {}".format(case_type, x, result))
        print("  Explanation: {}".format(explanation))
        print()


def analyze_algorithm_efficiency():
    """Compare different approaches in terms of efficiency"""
    print("\n=== Algorithm Efficiency Analysis ===")
    
    approaches = [
        ("Half Reverse", "O(log x / 2)", "O(1)", "Optimal - avoids overflow, minimal operations"),
        ("Full Reverse", "O(log x)", "O(1)", "Simple but potential overflow issues"),
        ("String Conversion", "O(log x)", "O(log x)", "Easiest to understand but uses extra space"),
        ("Digit Array", "O(log x)", "O(log x)", "Educational but inefficient")
    ]
    
    print("Approach | Time | Space | Notes")
    print("-" * 60)
    for name, time, space, notes in approaches:
        print("{:<15} | {:<8} | {:<8} | {}".format(name, time, space, notes))
    
    print("\nKey advantages of half-reverse approach:")
    print("1. No risk of integer overflow")
    print("2. Processes only half the digits")  
    print("3. Constant space complexity")
    print("4. Handles both even and odd length numbers elegantly")


def demonstrate_why_half_reverse_works():
    """Explain the mathematical reasoning behind half-reverse"""
    print("\n=== Why Half-Reverse Works ===")
    
    print("For a palindrome, first half mirrors second half:")
    print()
    
    print("Even length example: 1221")
    print("  First half: 12")
    print("  Second half: 21 (reverse of 12)")
    print("  When we reverse second half: 12")
    print("  Compare: first_half(12) == reversed_second_half(12) ✓")
    print()
    
    print("Odd length example: 12321") 
    print("  First half: 12")
    print("  Middle digit: 3 (can be ignored)")
    print("  Second half: 21 (reverse of 12)")
    print("  When we reverse second half: 123")
    print("  Compare: first_half(12) == reversed_second_half//10(12) ✓")
    print()
    
    print("Stopping condition: x <= reversed_half")
    print("  This ensures we've processed exactly half the digits")
    print("  For odd length, middle digit ends up in reversed_half")


if __name__ == "__main__":
    test_palindrome_solutions()
    demonstrate_half_reverse_algorithm()
    explain_edge_cases()
    analyze_algorithm_efficiency()
    demonstrate_why_half_reverse_works()
    
    print("\n=== Key Takeaways ===")
    print("1. Half-reverse approach is optimal: O(log x) time, O(1) space")
    print("2. Handle edge cases: negative numbers, trailing zeros")
    print("3. No string conversion needed for mathematical solution")
    print("4. Avoids overflow by processing only half the digits")
    print("5. Elegant handling of both even and odd length numbers")
